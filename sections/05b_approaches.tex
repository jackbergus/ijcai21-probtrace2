\section{Use Case Scenarios}
\subsection{Conformance Checking}
A business process describes (possibly concurrent) sequences of actions carried out by at least one agent for pursuing a final goal. The sequentialization of each transaction can be described as a \textit{trace} $\sigma\in\tasks^*$, where different \textit{labels} $\const{a}\in\tasks$ are used to distinguish actions. 
%Within the context of business processes, 
\textit{Conformance checking} assesses the degree of deviance of a log $\mathcal{L}$ towards the mined model $\mathcal{D}$ and vice-versa. Such deviance is often reduced to a  trace alignment problem \cite{DBLP:conf/edoc/AdriansyahDA11}, where each log-trace $\sigma'\in\mathcal{L}$ is compared to a model trace $\sigma$. Alignments empower explainability, as they describe the repairs required to make $\sigma'$ conformant to $\sigma$, and provides a numerical description of  their similarity.  

A finite \textit{log} $\mathcal{L}$ can be compactly represented as a model $\mathcal{D}$ via process  mining. Each model $\mathcal{D}$ describes a language $L[\mathcal{D}]\supseteq\mathcal{L}$. We can fit such models into two main categories: while \textit{procedural models} \cite{DBLP:journals/tosem/PolyvyanyySWCM20} %DBLP:conf/bpm/LeemansSA19,DBLP:conf/icpm/PolyvyanyyK19,
 enlist all the desired traces by unfolding,  \textit{declarative models} \cite{BurattinMAS12} offer the logical constraints that any desired trace should satisfy. Declarative models can be described via the Declare language, which can be totally described by node-labelled graphs \cite{GiacomoMM14}. Although the induced language is a countably infinite set of traces, it is always possible to prune it down to a finite set  by enumerating the candidate traces via an A* algorithm \cite{LeoniMA12}, and then representing the remaining traces directly as Transition Graphs in Fig. \ref{fig:taustar}. Henceforth, string alignments will not consider transition probabilities. Similar considerations can be also carried out for procedural models, as Petri Nets can be described by node-labelled graphs. %described by Petri Nets.
 
Multi-perspective approaches additionally consider property-value associations within the traces by extending process mining models with additional conditions \cite{GiacomoMGMM14}, namely guards \cite{MannhardtLRA16}. After enumerating all the possible model guards  $\mathbf{P}$, multi-perspective conformance checking can be always reduced to the non multi-perspective solutions by  re-labelling each $\const{a}$-labelled trace state satisfying  $P_i\in\mathbf{P}$ as $\const{a}{P_i}$ and applying a similar relabelling in the graph representation associated to the model.

 
Last, probabilisitic procedural models are gaining importance \cite{DBLP:conf/bpm/LeemansSA19,DBLP:conf/icpm/PolyvyanyyK19,DBLP:journals/tosem/PolyvyanyySWCM20}: such solutions are only assessing the degree of conformance without providing explainable results. Still, we can always formulate such problem into a probabilistic string alignment problem via our computation pipeline.
Without loss of generality, probabilistic procedural models are described by Stochastic Petri Nets, as BPMN models can be always be transformed to Stochastic Petri nets \cite{RaedtsPUWGS07} joinly with firing weight estimators \cite{spdwe}; concurrent processes can now be sequentialized as probabilistic TGs via reachability graphs (Fig. \ref{fig:lmc}), thus enabling  alignments over procedural models via $\overline{G}$ projection over traces. An alignment of a trace with a probabilistic procedural model is now the model trace maximizing the combined provision of minimum trace alignment cost and maximum model trace probability. 
 





%Despite probabilistic conformance checking approaches are gaining importance \cite{DBLP:conf/bpm/LeemansSA19,DBLP:conf/icpm/PolyvyanyyK19,DBLP:journals/tosem/PolyvyanyySWCM20}, these do not exploit trace alignments techniques, thus failing at explainabilty. Given that it is always possible to sequentialize Stochastic Petri Nets as Transition Graphs \cite{MarsanCB84}, we can describe each trace from the procedural model via $\overline{G}$ projection over traces, thus validating the usage of the proposed computation pipeline as a whole: an alignment of a trace with a procedural model is now the model trace maximizing the combined provision of minimum trace alignment cost and maximum model trace probability.



\subsection{Biological Sequence Analysis}
Similarly to conformance checking, biological sequence analysis assumes that sequence homology can be reduced to sequence alignments where sequences are represented as strings \cite{durbin1998biological}. When sequence similarity is weak, it is hard to identify the most significant alignment to prefer. In such situations, the sequence similarity is often combined with the probability for better ranking the preferred alignments \cite{durbin1998biological}. This is a shared point with our proposed approach. 

Biological sequences of interest, such as CpG islands \cite{kxq005} or full DNA sequences \cite{BISHOP1986159}, can be summarized into a probabilistic model, either via node-labelled Discrete-Time Markov Chains (PNFA) \cite{RyabkoU08} or Hidden Markov Models \cite{Helske2018}. Given that it is always possible to represent the latter as the former \cite{DUPONT20051349} and given that the former can be easily represented as Transition Graphs, we will only consider node-labelled DTMC. The probability of reaching a state $s_t$ with a given label $\lambda(s)$ after visiting $t$ other states only depends on the previously visited state $s_{t+1}$, thus making such models memoryless. Therefore, every biological sequence's probability is the joint probability of the transition probabilities required to visit the multigraph associated to the DTMC for generating the sequence. The probability associated with each biological sequence reflects the likelihood of having the final trace within the set of traces of interest. 

Such techniques often exploit well-known algorithms for returning the probabilistic model's best alignment towards the sequence of interest. E.g., the Viterbi Algorithm \cite{Viterbi67} returns the probabilistic model's path optimizing both trace probability and sequence similarity.  Nevertheless, the user could prefer a sequence with more significant similarity albeit underrepresented within the probabilistic model, while, in other cases, the user could favor a model trace with a higher probability at the expense of a lower homology. Thus, such an algorithm becomes unideal. In such situations, we problem still reduces to first enumerating all the more probable model traces for then skimming out the less likely to be candidate alignments for the given trace. This strategy is indeed the one pursued by our proposed approach. 


\subsection{Plan Recognition}
Plan recognition aims at inferring an actor's goal  by watching its activities. The possibility of exhaustively enumerating all the possible activities is commonly assumed  \cite{RamirezG09}. Still,  %Still, agents are not necessarily  rational thus not pursuing the optimal path for reaching the goal. 
%, or 
an unexpected context change could make the agent change its plan to $\sigma''$. As the already-executed plan $\sigma'$ cannot be retracted, the resulting plan after the context change $\overline{\sigma}$ shares intermediate features between $\sigma''$ and $\sigma'$ \cite{FoxGLS06}, which differences can be described by plan repairs.